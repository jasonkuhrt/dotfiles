#!/usr/bin/env bash
set -euo pipefail

# git-agent — Control agent git access permissions.
# https://git-scm.com/docs/git#_low_level_commands_plumbing (custom command convention)

VERSION="1.0.0"

# ── Helpers ────────────────────────────────────────────────

die() { printf "fatal: %s\n" "$1" >&2; exit 1; }

require_git() {
  GIT_DIR="$(git rev-parse --git-dir 2>/dev/null)" || die "not a git repository"
  PROJECT_ROOT="$(git rev-parse --show-toplevel 2>/dev/null)" || die "cannot find project root"
}

state_file()       { echo "$GIT_DIR/agent-state"; }
hooks_dir()        { echo "$GIT_DIR/agent-hooks"; }
saved_hookspath()  { echo "$GIT_DIR/agent-original-hookspath"; }

# ── State ──────────────────────────────────────────────────

init_state() {
  local sf
  sf="$(state_file)"
  if [ ! -f "$sf" ]; then
    printf "commit=off\npush=off\n" > "$sf"
  fi
}

read_gate() {
  local gate="$1" sf
  sf="$(state_file)"
  if [ -f "$sf" ]; then
    grep "^${gate}=" "$sf" 2>/dev/null | cut -d= -f2
  else
    echo "off"
  fi
}

write_gates() {
  local commit="$1" push="$2"
  printf "commit=%s\npush=%s\n" "$commit" "$push" > "$(state_file)"
}

# ── CLAUDE.local.md ───────────────────────────────────────

MARKER_START="<!-- git-agent:start -->"
MARKER_END="<!-- git-agent:end -->"

update_claude_local() {
  local commit push claude_file
  commit="$(read_gate commit)"
  push="$(read_gate push)"
  claude_file="$PROJECT_ROOT/CLAUDE.local.md"

  if [ "$commit" = "on" ] && [ "$push" = "on" ]; then
    # No restrictions — remove section
    remove_claude_section "$claude_file"
    return
  fi

  # Build status lines
  local commit_line push_line
  if [ "$commit" = "on" ]; then
    commit_line="| commit | allowed |"
  else
    commit_line="| commit | **BLOCKED** |"
  fi
  if [ "$push" = "on" ]; then
    push_line="| push | allowed |"
  else
    push_line="| push | **BLOCKED** |"
  fi

  local section
  section="$MARKER_START
## Agent Git Permissions

You do NOT have permission to run any \`git agent\` commands. Only the human controls these settings.

| Operation | Status |
|-----------|--------|
$commit_line
$push_line

Do not attempt blocked operations. Do not attempt workarounds. If you need to perform a blocked operation, stop and tell the human.
$MARKER_END"

  write_claude_section "$claude_file" "$section"
}

write_claude_section() {
  local file="$1" section="$2"

  if [ ! -f "$file" ]; then
    printf "%s\n" "$section" > "$file"
    return
  fi

  if grep -q "$MARKER_START" "$file"; then
    # Replace: before marker + new section + after marker
    local tmp="${file}.tmp"
    {
      sed "/$MARKER_START/,\$d" "$file"
      printf "%s\n" "$section"
      sed "1,/$MARKER_END/d" "$file"
    } > "$tmp" && mv "$tmp" "$file"
  else
    # Append
    printf "\n%s\n" "$section" >> "$file"
  fi
}

remove_claude_section() {
  local file="$1"
  [ ! -f "$file" ] && return 0
  grep -q "$MARKER_START" "$file" || return 0

  awk '
    /<!-- git-agent:start -->/ { skip=1; next }
    /<!-- git-agent:end -->/   { skip=0; next }
    !skip { print }
  ' "$file" > "${file}.tmp" && mv "${file}.tmp" "$file"

  # Remove trailing blank lines
  sed -i '' -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$file" 2>/dev/null || true

  # Remove file if empty
  if [ ! -s "$file" ]; then
    rm -f "$file"
  fi
}

# ── Hook Generation ───────────────────────────────────────

generate_hook() {
  local hook_name="$1" gate="$2"
  local hook_path
  hook_path="$(hooks_dir)/$hook_name"

  sed "s/@@GATE@@/$gate/g; s/@@HOOK@@/$hook_name/g" << 'HOOK' > "$hook_path"
#!/usr/bin/env bash
# Generated by git-agent. Do not edit.
GIT_DIR="$(git rev-parse --git-dir 2>/dev/null)" || exit 0

chain_to_original() {
  local original
  original="$(cat "$GIT_DIR/agent-original-hookspath" 2>/dev/null || true)"
  if [ -n "$original" ] && [ -x "$original/@@HOOK@@" ]; then
    exec "$original/@@HOOK@@" "$@"
  fi
}

# Non-agents pass through to original hooks
if [ -z "${CLAUDE_CODE:-}" ]; then
  chain_to_original "$@"
  exit 0
fi

# Check gate
gate_value="off"
state_file="$GIT_DIR/agent-state"
if [ -f "$state_file" ]; then
  gate_value="$(grep '^@@GATE@@=' "$state_file" 2>/dev/null | cut -d= -f2 || echo off)"
fi

if [ "$gate_value" != "on" ]; then
  commit_state="$(grep '^commit=' "$state_file" 2>/dev/null | cut -d= -f2 || echo off)"
  push_state="$(grep '^push=' "$state_file" 2>/dev/null | cut -d= -f2 || echo off)"

  cat <<EOF

━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
  GIT AGENT: @@GATE@@ is BLOCKED
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

You do not have permission to @@GATE@@. Your human collaborator
has explicitly disabled this operation.

There is NO POINT in retrying. This is a hard gate, not a
transient error. The fact that you attempted this means you
are misaligned with your human's intent.

STOP. Reconsider your actions carefully before proceeding.

The human can change this by running:

  git agent on @@GATE@@    # allow @@GATE@@
  git agent on             # allow all operations

Current state:
  commit: ${commit_state}
  push:   ${push_state}
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

EOF
  exit 1
fi

# Gate open — chain to original hooks
chain_to_original "$@"
HOOK

  chmod +x "$hook_path"
}

# ── Install / Uninstall ──────────────────────────────────

is_installed() {
  [ -d "$(hooks_dir)" ]
}

do_install() {
  if is_installed; then
    return 0
  fi

  local hd
  hd="$(hooks_dir)"
  mkdir -p "$hd"

  # Save current worktree-level hooksPath (if any)
  local current_hookspath
  current_hookspath="$(git config --worktree core.hooksPath 2>/dev/null || echo "")"
  printf "%s" "$current_hookspath" > "$(saved_hookspath)"

  # Generate hooks
  generate_hook "pre-commit" "commit"
  generate_hook "pre-push" "push"

  # Point this worktree at our hooks (doesn't affect other worktrees)
  git config --worktree core.hooksPath "$hd"

  # Init state
  init_state

  # Update CLAUDE.local.md
  update_claude_local

  printf "git-agent: installed\n"
  printf "  hooks: %s\n" "$hd"
  printf "  state: %s\n" "$(state_file)"
}

do_uninstall() {
  if ! is_installed; then
    printf "git-agent: not installed in this repository\n"
    return 0
  fi

  # Restore original worktree-level hooksPath
  local saved
  saved="$(cat "$(saved_hookspath)" 2>/dev/null || true)"
  if [ -n "$saved" ]; then
    git config --worktree core.hooksPath "$saved"
  else
    git config --worktree --unset core.hooksPath 2>/dev/null || true
  fi

  # Remove files
  rm -rf "$(hooks_dir)"
  rm -f "$(state_file)"
  rm -f "$(saved_hookspath)"

  # Remove CLAUDE.local.md section
  remove_claude_section "$PROJECT_ROOT/CLAUDE.local.md"

  printf "git-agent: uninstalled\n"
}

# ── Status ────────────────────────────────────────────────

show_status() {
  local commit push
  commit="$(read_gate commit)"
  push="$(read_gate push)"

  printf "git-agent"
  if is_installed; then
    printf " (installed)\n"
  else
    printf " (not installed)\n"
  fi
  printf "  commit: %s\n" "$commit"
  printf "  push:   %s\n" "$push"
}

# ── Help ──────────────────────────────────────────────────

show_help() {
  cat <<'HELP'
git-agent — Control agent git access permissions.

Usage:
  git agent              Show current status
  git agent r            Read-only mode (block all writes)
  git agent off          Alias for r
  git agent w            Read-write mode (allow all writes)
  git agent on           Alias for w
  git agent on commit    Allow commits
  git agent on push      Allow pushes (also enables commit)
  git agent off commit   Block commits (also blocks push)
  git agent off push     Block pushes
  git agent install      Set up hooks (auto-runs on first use)
  git agent uninstall    Remove all traces from this repository

State is stored in .git/agent-state (local, not committed).
Rules are written to CLAUDE.local.md (gitignored).
HELP
}

# ── Main ──────────────────────────────────────────────────

cmd="${1:-}"
target="${2:-}"

# Help doesn't need a git repo
case "$cmd" in
  --help|help|-h) show_help; exit 0 ;;
  --version) echo "git-agent $VERSION"; exit 0 ;;
esac

require_git

# Auto-install for all commands except uninstall and status
case "$cmd" in
  ""|uninstall) ;;
  *) do_install ;;
esac

case "$cmd" in
  "")
    show_status
    ;;

  install)
    # do_install already ran above
    show_status
    ;;

  uninstall)
    do_uninstall
    ;;

  r|off)
    if [ -n "$target" ]; then
      case "$cmd" in
        off) ;; # off commit / off push is valid
        r) die "'r' does not take arguments (did you mean: git agent off $target?)" ;;
      esac
      case "$target" in
        commit)
          # off commit → also off push (cascade)
          write_gates "off" "off"
          update_claude_local
          printf "commit: off, push: off (cascade)\n"
          ;;
        push)
          write_gates "$(read_gate commit)" "off"
          update_claude_local
          printf "commit: %s, push: off\n" "$(read_gate commit)"
          ;;
        *) die "unknown target: $target (expected: commit, push)" ;;
      esac
    else
      write_gates "off" "off"
      update_claude_local
      printf "commit: off, push: off\n"
    fi
    ;;

  w|on)
    if [ -n "$target" ]; then
      case "$cmd" in
        on) ;; # on commit / on push is valid
        w) die "'w' does not take arguments (did you mean: git agent on $target?)" ;;
      esac
      case "$target" in
        commit)
          write_gates "on" "$(read_gate push)"
          update_claude_local
          printf "commit: on, push: %s\n" "$(read_gate push)"
          ;;
        push)
          # on push → also on commit (cascade)
          write_gates "on" "on"
          update_claude_local
          printf "commit: on, push: on (cascade)\n"
          ;;
        *) die "unknown target: $target (expected: commit, push)" ;;
      esac
    else
      write_gates "on" "on"
      update_claude_local
      printf "commit: on, push: on\n"
    fi
    ;;

  *)
    die "unknown command: $cmd (try: git agent --help)"
    ;;
esac
