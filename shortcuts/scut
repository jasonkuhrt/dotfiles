#!/bin/bash
# @describe scut — Apple Shortcuts development toolkit
# @describe
# @describe Unified CLI for Shortcuts action discovery, code generation, debugging,
# @describe and workflow routing. Queries the macOS ToolKit database for structural
# @describe data and merges curated behavioral knowledge from YAML overlays.
# @describe
# @describe Requires: Full Disk Access for your terminal app
# @describe   System Settings → Privacy & Security → Full Disk Access → add terminal
# @describe
# @describe Community & Resources: scut community

set -euo pipefail
SCRIPT_DIR="$(cd "$(dirname "$0")" && pwd)"

# ─── Config ──────────────────────────────────────────────────────────
CHERRI="${SCUT_CHERRI:-cherri}"
KNOWLEDGE_DIR="$SCRIPT_DIR/knowledge"
DB=""
SHORTCUTS_DB="$HOME/Library/Shortcuts/Shortcuts.sqlite"

# ─── Helpers ─────────────────────────────────────────────────────────

_die() { printf "error: %s\n" "$1" >&2; exit 1; }
_sq() { echo "${1//\'/\'\'}"; }

_require_db() {
    DB=$(find ~/Library/Shortcuts/ToolKit -name "Tools-prod.*.sqlite" 2>/dev/null | head -1)
    if [[ -z "$DB" ]]; then
        _die "ToolKit database not found.
  Grant Full Disk Access: System Settings → Privacy & Security → Full Disk Access
  Add your terminal app, then restart it."
    fi
}

_require_yq() { command -v yq &>/dev/null || _die "yq required: brew install yq"; }
_require_jq() { command -v jq &>/dev/null || _die "jq required: brew install jq"; }

_require_shortcuts_db() {
    if [[ ! -r "$SHORTCUTS_DB" ]]; then
        _die "Cannot read Shortcuts database. Grant Full Disk Access to your terminal.
  System Settings → Privacy & Security → Full Disk Access"
    fi
}

_sql() { sqlite3 -separator '|' "$DB" "$1"; }
_sql_header() { sqlite3 -header -separator '|' "$DB" "$1"; }
_sdb() { sqlite3 -separator '|' "$SHORTCUTS_DB" "$1"; }
_sdb_header() { sqlite3 -header -separator '|' "$SHORTCUTS_DB" "$1"; }

# Get app display name from container metadata
_app_name() {
    local bundle_id="$1"
    _sql "SELECT COALESCE(cml.name, cm.id)
          FROM ContainerMetadata cm
          LEFT JOIN ContainerMetadataLocalizations cml
            ON cm.rowId = cml.containerId AND cml.locale = 'en'
          WHERE cm.id = '$bundle_id'
          LIMIT 1;" 2>/dev/null || echo "$bundle_id"
}

# Extract bundle ID from a full action identifier
_bundle_from_id() {
    local id="$1"
    # Third-party: com.foo.bar.ActionName → com.foo.bar
    # Apple: is.workflow.actions.name → is.workflow
    if [[ "$id" == is.workflow.* ]]; then
        echo "is.workflow"
    elif [[ "$id" == com.apple.* ]]; then
        # com.apple.Something.ActionName → extract up to container
        _sql "SELECT cm.id FROM Tools t
              JOIN ContainerMetadata cm ON t.sourceContainerId = cm.rowId
              WHERE t.id = '$id' LIMIT 1;" 2>/dev/null || echo "${id%.*}"
    else
        _sql "SELECT cm.id FROM Tools t
              JOIN ContainerMetadata cm ON t.sourceContainerId = cm.rowId
              WHERE t.id = '$id' LIMIT 1;" 2>/dev/null || echo "${id%.*}"
    fi
}

# Find knowledge file for a bundle ID
_knowledge_file() {
    local bundle_id="$1"
    if [[ ! -d "$KNOWLEDGE_DIR" ]]; then return 1; fi
    for f in "$KNOWLEDGE_DIR"/*.yml; do
        [[ -f "$f" ]] || continue
        local file_bundle
        file_bundle=$(yq -r '.bundle_id // ""' "$f" 2>/dev/null)
        if [[ "$file_bundle" == "$bundle_id" ]]; then
            echo "$f"
            return 0
        fi
    done
    return 1
}

# Get knowledge for a specific action
_knowledge_action() {
    local action_name="$1"
    local knowledge_file="$2"
    if [[ -f "$knowledge_file" ]]; then
        yq -r ".actions.\"$action_name\" // \"\"" "$knowledge_file" 2>/dev/null
    fi
}

# Resolve action: substring match, return full ID(s)
_resolve_action() {
    local filter="$1"
    _sql "SELECT id FROM Tools WHERE id LIKE '%${filter}%' ORDER BY id;"
}

# ─── Phase 1: Discovery ─────────────────────────────────────────────

# @cmd Show ToolKit database statistics
stats() {
    _require_db

    local total apple workflow thirdparty
    total=$(_sql "SELECT COUNT(*) FROM Tools;")
    apple=$(_sql "SELECT COUNT(*) FROM Tools WHERE id LIKE 'com.apple.%';")
    workflow=$(_sql "SELECT COUNT(*) FROM Tools WHERE id LIKE 'is.workflow.%';")
    thirdparty=$(_sql "SELECT COUNT(*) FROM Tools
                       WHERE id NOT LIKE 'com.apple.%' AND id NOT LIKE 'is.workflow.%';")

    if [[ "${argc_json:-}" == "1" ]]; then
        _require_jq
        jq -n \
            --arg total "$total" \
            --arg apple "$apple" \
            --arg workflow "$workflow" \
            --arg thirdparty "$thirdparty" \
            --arg db "$DB" \
            '{database: $db, total: ($total|tonumber), apple: ($apple|tonumber),
              workflow: ($workflow|tonumber), thirdparty: ($thirdparty|tonumber)}'
        return
    fi

    echo "Shortcuts ToolKit Database"
    echo "=========================="
    echo ""
    echo "Database: $DB"
    echo ""
    printf "  %-22s %s\n" "Total actions:" "$total"
    printf "  %-22s %s\n" "Apple actions:" "$apple"
    printf "  %-22s %s\n" "Shortcuts built-in:" "$workflow"
    printf "  %-22s %s\n" "Third-party actions:" "$thirdparty"
}

# @cmd List apps providing Shortcuts actions
# @flag --json Machine-readable JSON output
apps() {
    _require_db

    if [[ "${argc_json:-}" == "1" ]]; then
        _require_jq
        local json="[]"
        while IFS='|' read -r container_id count; do
            local name
            name=$(_app_name "$container_id")
            json=$(echo "$json" | jq \
                --arg id "$container_id" \
                --arg name "$name" \
                --arg count "$count" \
                '. + [{bundle_id: $id, name: $name, action_count: ($count|tonumber)}]')
        done < <(_sql "
            SELECT cm.id, COUNT(*) as cnt
            FROM Tools t
            JOIN ContainerMetadata cm ON t.sourceContainerId = cm.rowId
            WHERE t.id NOT LIKE 'com.apple.%'
            GROUP BY cm.id
            ORDER BY cnt DESC;
        ")
        echo "$json" | jq .
        return
    fi

    echo "Apps with Shortcuts actions:"
    echo ""
    while IFS='|' read -r container_id count; do
        local name
        name=$(_app_name "$container_id")
        if [[ "$name" != "$container_id" ]]; then
            printf "  %-30s %-40s %s actions\n" "$name" "($container_id)" "$count"
        else
            printf "  %-72s %s actions\n" "$container_id" "$count"
        fi
    done < <(_sql "
        SELECT cm.id, COUNT(*) as cnt
        FROM Tools t
        JOIN ContainerMetadata cm ON t.sourceContainerId = cm.rowId
        WHERE t.id NOT LIKE 'com.apple.%'
        GROUP BY cm.id
        ORDER BY cnt DESC;
    ")
}

# @cmd List actions, optionally filtered by app
# @arg app Filter by app name or bundle ID (substring match)
# @flag --json Machine-readable JSON output
actions() {
    _require_db
    local filter="${argc_app:-}"

    local where="1=1"
    if [[ -n "$filter" ]]; then
        where="(t.id LIKE '%${filter}%' OR cm.id LIKE '%${filter}%' OR COALESCE(cml.name,'') LIKE '%${filter}%')"
    fi

    if [[ "${argc_json:-}" == "1" ]]; then
        _require_jq
        local json="[]"
        while IFS='|' read -r action_id name desc app_name; do
            json=$(echo "$json" | jq \
                --arg id "$action_id" \
                --arg name "$name" \
                --arg desc "$desc" \
                --arg app "$app_name" \
                '. + [{identifier: $id, name: $name, description: $desc, app: $app}]')
        done < <(_sql "
            SELECT t.id,
                   COALESCE(tl.name, ''),
                   COALESCE(tl.descriptionSummary, ''),
                   COALESCE(cml.name, cm.id)
            FROM Tools t
            JOIN ContainerMetadata cm ON t.sourceContainerId = cm.rowId
            LEFT JOIN ContainerMetadataLocalizations cml ON cm.rowId = cml.containerId AND cml.locale = 'en'
            LEFT JOIN ToolLocalizations tl ON t.rowId = tl.toolId AND tl.locale = 'en' AND tl.localizationUsage = 'display'
            WHERE $where
            ORDER BY t.id;
        ")
        echo "$json" | jq .
        return
    fi

    if [[ -n "$filter" ]]; then
        echo "Actions matching '$filter':"
    else
        echo "All third-party actions:"
    fi
    echo ""

    while IFS='|' read -r action_id name desc app_name; do
        if [[ -n "$name" ]]; then
            printf "  %-60s %s (%s)\n" "$action_id" "$name" "$app_name"
        else
            printf "  %s\n" "$action_id"
        fi
    done < <(_sql "
        SELECT t.id,
               COALESCE(tl.name, ''),
               COALESCE(tl.descriptionSummary, ''),
               COALESCE(cml.name, cm.id)
        FROM Tools t
        JOIN ContainerMetadata cm ON t.sourceContainerId = cm.rowId
        LEFT JOIN ContainerMetadataLocalizations cml ON cm.rowId = cml.containerId AND cml.locale = 'en'
        LEFT JOIN ToolLocalizations tl ON t.rowId = tl.toolId AND tl.locale = 'en' AND tl.localizationUsage = 'display'
        WHERE $where
        ORDER BY t.id
        LIMIT 200;
    ")
}

# @cmd Full-text search across action names, descriptions, and keywords
# @arg term! Search term
# @flag --json Machine-readable JSON output
search() {
    _require_db
    local term="${argc_term}"

    if [[ "${argc_json:-}" == "1" ]]; then
        _require_jq
        local json="[]"
        while IFS='|' read -r action_id name desc app_name; do
            json=$(echo "$json" | jq \
                --arg id "$action_id" \
                --arg name "$name" \
                --arg desc "$desc" \
                --arg app "$app_name" \
                '. + [{identifier: $id, name: $name, description: $desc, app: $app}]')
        done < <(_sql "
            SELECT DISTINCT t.id,
                   COALESCE(tl.name, ''),
                   COALESCE(tl.descriptionSummary, ''),
                   COALESCE(cml.name, cm.id)
            FROM Tools t
            JOIN ContainerMetadata cm ON t.sourceContainerId = cm.rowId
            LEFT JOIN ContainerMetadataLocalizations cml ON cm.rowId = cml.containerId AND cml.locale = 'en'
            LEFT JOIN ToolLocalizations tl ON t.rowId = tl.toolId AND tl.locale = 'en' AND tl.localizationUsage = 'display'
            LEFT JOIN SearchKeywords sk ON t.rowId = sk.toolId AND sk.locale = 'en'
            WHERE (t.id LIKE '%${term}%'
               OR tl.name LIKE '%${term}%'
               OR tl.descriptionSummary LIKE '%${term}%'
               OR sk.keyword LIKE '%${term}%')
            ORDER BY t.id
            LIMIT 50;
        ")
        echo "$json" | jq .
        return
    fi

    echo "Actions matching '$term':"
    echo ""
    while IFS='|' read -r action_id name desc app_name; do
        printf "  %-60s %s\n" "$action_id" "$name"
        if [[ -n "$desc" ]]; then
            printf "  %-60s   %s\n" "" "$desc"
        fi
    done < <(_sql "
        SELECT DISTINCT t.id,
               COALESCE(tl.name, ''),
               COALESCE(tl.descriptionSummary, ''),
               COALESCE(cml.name, cm.id)
        FROM Tools t
        JOIN ContainerMetadata cm ON t.sourceContainerId = cm.rowId
        LEFT JOIN ContainerMetadataLocalizations cml ON cm.rowId = cml.containerId AND cml.locale = 'en'
        LEFT JOIN ToolLocalizations tl ON t.rowId = tl.toolId AND tl.locale = 'en' AND tl.localizationUsage = 'display'
        LEFT JOIN SearchKeywords sk ON t.rowId = sk.toolId AND sk.locale = 'en'
        WHERE t.id LIKE '%${term}%'
           OR tl.name LIKE '%${term}%'
           OR tl.descriptionSummary LIKE '%${term}%'
           OR sk.keyword LIKE '%${term}%'
        ORDER BY t.id
        LIMIT 50;
    ")
}

# @cmd Show action parameters with types, descriptions, and enum values
# @arg action! Action name or identifier (substring match)
# @flag --json Machine-readable JSON output
params() {
    _require_db
    local filter="${argc_action}"

    local matching
    matching=$(_resolve_action "$filter")
    if [[ -z "$matching" ]]; then
        _die "No actions found matching '$filter'"
    fi

    if [[ "${argc_json:-}" == "1" ]]; then
        _require_jq
        _require_yq
        local json="[]"
        while IFS= read -r action_id; do
            local action_json
            action_json=$(_params_json "$action_id")
            json=$(echo "$json" | jq --argjson item "$action_json" '. + [$item]')
        done <<< "$matching"
        echo "$json" | jq .
        return
    fi

    _require_yq
    while IFS= read -r action_id; do
        _params_display "$action_id"
    done <<< "$matching"
}

_params_json() {
    local action_id="$1"
    local name desc app_name
    IFS='|' read -r name desc app_name < <(_sql "
        SELECT COALESCE(tl.name, ''),
               COALESCE(tl.descriptionSummary, ''),
               COALESCE(cml.name, cm.id)
        FROM Tools t
        JOIN ContainerMetadata cm ON t.sourceContainerId = cm.rowId
        LEFT JOIN ContainerMetadataLocalizations cml ON cm.rowId = cml.containerId AND cml.locale = 'en'
        LEFT JOIN ToolLocalizations tl ON t.rowId = tl.toolId AND tl.locale = 'en' AND tl.localizationUsage = 'display'
        WHERE t.id = '$action_id'
        LIMIT 1;
    ")

    local params_json="[]"
    while IFS='|' read -r key param_name param_desc; do
        params_json=$(echo "$params_json" | jq \
            --arg key "$key" \
            --arg name "$param_name" \
            --arg desc "$param_desc" \
            '. + [{key: $key, name: $name, description: $desc}]')
    done < <(_sql "
        SELECT p.key, COALESCE(pl.name, p.key), COALESCE(pl.description, '')
        FROM Parameters p
        LEFT JOIN ParameterLocalizations pl
            ON p.toolId = pl.toolId AND p.key = pl.key AND pl.locale = 'en'
        WHERE p.toolId = (SELECT rowId FROM Tools WHERE id = '$action_id')
        ORDER BY p.sortOrder;
    ")

    # Check knowledge overlay
    local bundle_id verified="false" gotchas="[]" examples="[]"
    bundle_id=$(_bundle_from_id "$action_id")
    local kfile
    if kfile=$(_knowledge_file "$bundle_id"); then
        local action_short="${action_id##*.}"
        local kdata
        kdata=$(yq -r ".actions.\"$action_short\" // \"\"" "$kfile" 2>/dev/null || true)
        if [[ -n "$kdata" ]]; then
            verified=$(echo "$kdata" | yq -r '.verified // false' 2>/dev/null || echo "false")
            gotchas=$(echo "$kdata" | yq -o=json '.gotchas // []' 2>/dev/null || echo "[]")
            examples=$(echo "$kdata" | yq -o=json '.examples // []' 2>/dev/null || echo "[]")
        fi
    fi

    jq -n \
        --arg id "$action_id" \
        --arg name "$name" \
        --arg desc "$desc" \
        --arg app "$app_name" \
        --arg verified "$verified" \
        --argjson params "$params_json" \
        --argjson gotchas "$gotchas" \
        --argjson examples "$examples" \
        '{identifier: $id, name: $name, description: $desc, app: $app,
          verified: ($verified == "true"), parameters: $params,
          gotchas: $gotchas, examples: $examples}'
}

_params_display() {
    local action_id="$1"

    echo "═══════════════════════════════════════════════════════════"
    echo "Action: $action_id"

    # Get localized name and description
    local name desc app_name
    IFS='|' read -r name desc app_name < <(_sql "
        SELECT COALESCE(tl.name, ''),
               COALESCE(tl.descriptionSummary, ''),
               COALESCE(cml.name, cm.id)
        FROM Tools t
        JOIN ContainerMetadata cm ON t.sourceContainerId = cm.rowId
        LEFT JOIN ContainerMetadataLocalizations cml ON cm.rowId = cml.containerId AND cml.locale = 'en'
        LEFT JOIN ToolLocalizations tl ON t.rowId = tl.toolId AND tl.locale = 'en' AND tl.localizationUsage = 'display'
        WHERE t.id = '$action_id'
        LIMIT 1;
    ")

    [[ -n "$name" ]] && echo "  Name: $name"
    [[ -n "$app_name" ]] && echo "  App: $app_name"
    [[ -n "$desc" ]] && echo "  Description: $desc"

    # Check knowledge overlay
    local bundle_id
    bundle_id=$(_bundle_from_id "$action_id")
    local kfile
    if kfile=$(_knowledge_file "$bundle_id"); then
        local action_short="${action_id##*.}"
        local verified
        verified=$(yq -r ".actions.\"$action_short\".verified // false" "$kfile" 2>/dev/null)
        if [[ "$verified" == "true" ]]; then
            echo "  Status: verified"
        fi

        local gotchas
        gotchas=$(yq -r ".actions.\"$action_short\".gotchas[]? // \"\"" "$kfile" 2>/dev/null || true)
        if [[ -n "$gotchas" ]]; then
            echo ""
            echo "  Gotchas:"
            while IFS= read -r gotcha; do
                echo "    - $gotcha"
            done <<< "$gotchas"
        fi
    fi

    echo ""
    echo "Parameters:"
    echo "───────────────────────────────────────────────────────────"

    local has_params=0
    while IFS='|' read -r key param_name param_desc; do
        has_params=1
        printf "  %-25s %s\n" "$key" "$param_name"
        if [[ -n "$param_desc" ]]; then
            printf "  %-25s   %s\n" "" "$param_desc"
        fi
    done < <(_sql "
        SELECT p.key, COALESCE(pl.name, p.key), COALESCE(pl.description, '')
        FROM Parameters p
        LEFT JOIN ParameterLocalizations pl
            ON p.toolId = pl.toolId AND p.key = pl.key AND pl.locale = 'en'
        WHERE p.toolId = (SELECT rowId FROM Tools WHERE id = '$action_id')
        ORDER BY p.sortOrder;
    ")

    if [[ $has_params -eq 0 ]]; then
        echo "  (no parameters)"
    fi
    echo ""
}

# @cmd Reverse lookup: display name → action identifier
# @arg name! Display name to look up (substring match)
# @flag --json Machine-readable JSON output
identifier() {
    _require_db
    local name="${argc_name}"

    if [[ "${argc_json:-}" == "1" ]]; then
        _require_jq
        local json="[]"
        while IFS='|' read -r action_id display_name app_name; do
            json=$(echo "$json" | jq \
                --arg id "$action_id" \
                --arg name "$display_name" \
                --arg app "$app_name" \
                '. + [{identifier: $id, name: $name, app: $app}]')
        done < <(_sql "
            SELECT t.id, tl.name, COALESCE(cml.name, cm.id)
            FROM ToolLocalizations tl
            JOIN Tools t ON tl.toolId = t.rowId
            JOIN ContainerMetadata cm ON t.sourceContainerId = cm.rowId
            LEFT JOIN ContainerMetadataLocalizations cml ON cm.rowId = cml.containerId AND cml.locale = 'en'
            WHERE tl.locale = 'en' AND tl.localizationUsage = 'display'
              AND tl.name LIKE '%${name}%'
            ORDER BY t.id
            LIMIT 20;
        ")
        echo "$json" | jq .
        return
    fi

    echo "Actions matching display name '$name':"
    echo ""
    while IFS='|' read -r action_id display_name app_name; do
        printf "  %-40s → %s (%s)\n" "$display_name" "$action_id" "$app_name"
    done < <(_sql "
        SELECT t.id, tl.name, COALESCE(cml.name, cm.id)
        FROM ToolLocalizations tl
        JOIN Tools t ON tl.toolId = t.rowId
        JOIN ContainerMetadata cm ON t.sourceContainerId = cm.rowId
        LEFT JOIN ContainerMetadataLocalizations cml ON cm.rowId = cml.containerId AND cml.locale = 'en'
        WHERE tl.locale = 'en' AND tl.localizationUsage = 'display'
          AND tl.name LIKE '%${name}%'
        ORDER BY t.id
        LIMIT 20;
    ")
}

# ─── Phase 2: Code Generation + Knowledge ────────────────────────────

# @cmd Generate rawAction() Cherri snippet for an action
# @arg action! Action name or identifier (substring match)
# @flag --json Machine-readable JSON output
cherri() {
    _require_db
    _require_yq
    local filter="${argc_action}"

    local matching
    matching=$(_resolve_action "$filter")
    if [[ -z "$matching" ]]; then
        _die "No actions found matching '$filter'"
    fi

    while IFS= read -r action_id; do
        local bundle_id action_short app_name
        bundle_id=$(_bundle_from_id "$action_id")
        action_short="${action_id##*.}"
        app_name=$(_app_name "$bundle_id")

        # Check knowledge overlay for verified examples
        local has_knowledge=false
        local kfile
        if kfile=$(_knowledge_file "$bundle_id"); then
            local verified
            verified=$(yq -r ".actions.\"$action_short\".verified // false" "$kfile" 2>/dev/null)
            if [[ "$verified" == "true" ]]; then
                has_knowledge=true
            fi
        fi

        if [[ "$has_knowledge" == "true" ]]; then
            # Render from knowledge examples
            echo "// ${app_name}: ${action_short} ✓"

            # Show gotchas as comments
            local gotchas
            gotchas=$(yq -r ".actions.\"$action_short\".gotchas[]? // \"\"" "$kfile" 2>/dev/null || true)
            if [[ -n "$gotchas" ]]; then
                while IFS= read -r gotcha; do
                    echo "// Gotcha: $gotcha"
                done <<< "$gotchas"
            fi
            echo ""

            # Render each example
            local example_count
            example_count=$(yq -r ".actions.\"$action_short\".examples | length" "$kfile" 2>/dev/null || echo "0")
            for ((i = 0; i < example_count; i++)); do
                local label
                label=$(yq -r ".actions.\"$action_short\".examples[$i].label // \"Example $((i+1))\"" "$kfile" 2>/dev/null || echo "Example $((i+1))")
                echo "// $label"

                echo "rawAction(\"$action_id\", {"
                # Get params as key-value pairs
                local params_json
                params_json=$(yq -o=json ".actions.\"$action_short\".examples[$i].params" "$kfile" 2>/dev/null || echo "{}")
                local keys
                keys=$(echo "$params_json" | jq -r 'keys[]' 2>/dev/null || true)
                local first=true
                while IFS= read -r key; do
                    [[ -z "$key" ]] && continue
                    local val
                    val=$(echo "$params_json" | jq -r ".\"$key\"" 2>/dev/null || echo "")
                    if [[ "$first" == "true" ]]; then
                        first=false
                    else
                        printf ",\n"
                    fi
                    printf "    \"%s\": \"%s\"" "$key" "$val"
                done <<< "$keys"
                echo ""
                echo "})"
                echo ""
            done
        else
            # Generate stub from DB params
            echo "// ${action_id} ⚠ unverified"
            echo "// Parameters from ToolKit DB:"

            local param_lines=""
            while IFS='|' read -r key param_name param_desc; do
                if [[ -n "$param_desc" ]]; then
                    param_lines+="    // $param_name: $param_desc"$'\n'
                fi
                param_lines+="    \"$key\": \"\""$'\n'
            done < <(_sql "
                SELECT p.key, COALESCE(pl.name, p.key), COALESCE(pl.description, '')
                FROM Parameters p
                LEFT JOIN ParameterLocalizations pl
                    ON p.toolId = pl.toolId AND p.key = pl.key AND pl.locale = 'en'
                WHERE p.toolId = (SELECT rowId FROM Tools WHERE id = '$action_id')
                ORDER BY p.sortOrder;
            ")

            echo "rawAction(\"$action_id\", {"
            if [[ -n "$param_lines" ]]; then
                echo -n "$param_lines" | sed '$ s/$//'
            else
                echo "    \"placeholder\": \"unused\"  // rawAction requires at least one param"
            fi
            echo "})"
            echo ""
        fi
    done <<< "$matching"
}

# @cmd Diff ToolKit DB vs knowledge overlay — show what's verified, new, uncurated
scan() {
    _require_db
    _require_yq

    echo "Shortcuts Action Coverage"
    echo "========================="
    echo ""

    # Get all third-party apps from DB
    while IFS='|' read -r bundle_id count; do
        local app_name
        app_name=$(_app_name "$bundle_id")

        local kfile verified_count=0
        if kfile=$(_knowledge_file "$bundle_id"); then
            verified_count=$(yq -r '[.actions // {} | to_entries[] | select(.value.verified == true)] | length' "$kfile" 2>/dev/null)
            local total_in_knowledge
            total_in_knowledge=$(yq -r '.actions // {} | length' "$kfile" 2>/dev/null)
            printf "  ✓ %-25s %3s actions  (%s verified, %s documented)\n" \
                "$app_name" "$count" "$verified_count" "$total_in_knowledge"
        else
            printf "  ⚠ %-25s %3s actions  (no knowledge file)\n" \
                "$app_name" "$count"
        fi
    done < <(_sql "
        SELECT cm.id, COUNT(*) as cnt
        FROM Tools t
        JOIN ContainerMetadata cm ON t.sourceContainerId = cm.rowId
        WHERE t.id NOT LIKE 'com.apple.%'
          AND t.id NOT LIKE 'is.workflow.%'
        GROUP BY cm.id
        ORDER BY cnt DESC;
    ")

    echo ""

    # Summary
    local total_third_party
    total_third_party=$(_sql "SELECT COUNT(*) FROM Tools
                              WHERE id NOT LIKE 'com.apple.%' AND id NOT LIKE 'is.workflow.%';")
    local total_workflow
    total_workflow=$(_sql "SELECT COUNT(*) FROM Tools WHERE id LIKE 'is.workflow.%';")

    echo "Third-party: $total_third_party actions"
    echo "Shortcuts built-in: $total_workflow actions"
}

# @cmd Mark an action as verified in its knowledge YAML file
# @arg action! Action identifier (must be exact short name, e.g. IsDarkModeOnIntent)
verify() {
    _require_db
    _require_yq
    local action_name="${argc_action}"

    # Find the action in DB
    local action_id
    action_id=$(_resolve_action "$action_name" | head -1)
    if [[ -z "$action_id" ]]; then
        _die "No action found matching '$action_name'"
    fi

    local bundle_id action_short
    bundle_id=$(_bundle_from_id "$action_id")
    action_short="${action_id##*.}"

    local kfile
    if ! kfile=$(_knowledge_file "$bundle_id"); then
        _die "No knowledge file for bundle '$bundle_id'. Create one first."
    fi

    yq -i ".actions.\"$action_short\".verified = true" "$kfile"
    echo "Marked $action_short as verified in $(basename "$kfile")"
}

# @cmd Add a gotcha note to an action's knowledge
# @arg action! Action identifier (short name)
# @arg text! The gotcha text
note() {
    _require_db
    _require_yq
    local action_name="${argc_action}"
    local text="${argc_text}"

    local action_id
    action_id=$(_resolve_action "$action_name" | head -1)
    if [[ -z "$action_id" ]]; then
        _die "No action found matching '$action_name'"
    fi

    local bundle_id action_short
    bundle_id=$(_bundle_from_id "$action_id")
    action_short="${action_id##*.}"

    local kfile
    if ! kfile=$(_knowledge_file "$bundle_id"); then
        _die "No knowledge file for bundle '$bundle_id'. Create one first."
    fi

    yq -i ".actions.\"$action_short\".gotchas += [\"$text\"]" "$kfile"
    echo "Added gotcha to $action_short in $(basename "$kfile")"
}

# @cmd Add an example to an action's knowledge from a successful test
# @arg action! Action identifier (short name)
# @option --label! Example label
# @option --params! JSON params string
learn() {
    _require_db
    _require_yq
    _require_jq
    local action_name="${argc_action}"
    local label="${argc_label}"
    local params_str="${argc_params}"

    local action_id
    action_id=$(_resolve_action "$action_name" | head -1)
    if [[ -z "$action_id" ]]; then
        _die "No action found matching '$action_name'"
    fi

    local bundle_id action_short
    bundle_id=$(_bundle_from_id "$action_id")
    action_short="${action_id##*.}"

    local kfile
    if ! kfile=$(_knowledge_file "$bundle_id"); then
        _die "No knowledge file for bundle '$bundle_id'. Create one first."
    fi

    # Validate JSON params
    echo "$params_str" | jq . > /dev/null 2>&1 || _die "Invalid JSON params: $params_str"

    # Convert JSON params to YAML and append
    local tmp
    tmp=$(mktemp)
    echo "$params_str" | yq -P '.' > "$tmp"
    local yaml_params
    yaml_params=$(cat "$tmp")
    rm -f "$tmp"

    yq -i ".actions.\"$action_short\".examples += [{\"label\": \"$label\", \"params\": $params_str}]" "$kfile"
    echo "Added example '$label' to $action_short in $(basename "$kfile")"
}

# ─── Phase 3: Workflow Routing + Debugging ────────────────────────────

# @cmd Compile a .cherri file (routes to cherri compiler)
# @arg file! Path to .cherri file
# @flag --skip-sign Skip signing (syntax check only)
# @flag --hubsign Sign via RoutineHub instead of macOS
build() {
    command -v "$CHERRI" &>/dev/null || _die "cherri not found. Install: brew tap electrikmilk/cherri && brew install electrikmilk/cherri/cherri
  Or set SCUT_CHERRI to point to your fork."

    local args=("${argc_file}")
    [[ "${argc_skip_sign:-}" == "1" ]] && args+=("--skip-sign")
    [[ "${argc_hubsign:-}" == "1" ]] && args+=("--hubsign")

    "$CHERRI" "${args[@]}"
}

# @cmd Compile and run a shortcut
# @arg file! Path to .cherri file
run() {
    build
    # Extract shortcut name from #define name in the file
    local name
    name=$(grep -E '^#define name ' "${argc_file}" | sed 's/^#define name //')
    if [[ -z "$name" ]]; then
        name=$(basename "${argc_file}" .cherri)
    fi
    echo "Importing and running '$name'..."
    open "${name}.shortcut" 2>/dev/null
    sleep 2
    shortcuts run "$name"
}

# @cmd Quick-test an action: generate tmp .cherri, compile, run, cleanup
# @arg identifier! Full action identifier
# @option --param* key=value parameters
try() {
    command -v "$CHERRI" &>/dev/null || _die "cherri not found"

    local action_id="${argc_identifier}"
    local tmp_dir
    tmp_dir=$(mktemp -d)
    local cherri_file="$tmp_dir/scut-test.cherri"

    # Build params
    local params=""
    if [[ -n "${argc_param+x}" ]]; then
        for p in "${argc_param[@]}"; do
            local key="${p%%=*}"
            local val="${p#*=}"
            if [[ -n "$params" ]]; then
                params+=","$'\n'
            fi
            params+="    \"$key\": \"$val\""
        done
    fi
    if [[ -z "$params" ]]; then
        params='    "placeholder": "unused"'
    fi

    cat > "$cherri_file" << EOF
#define name scut-test
#define color gray
#define glyph wrench

rawAction("$action_id", {
$params
})
EOF

    echo "Testing: $action_id"
    echo "─────────────────────"
    cat "$cherri_file"
    echo "─────────────────────"

    if "$CHERRI" "$cherri_file" 2>&1; then
        local shortcut_file="$tmp_dir/scut-test.shortcut"
        if [[ -f "scut-test.shortcut" ]]; then
            mv "scut-test.shortcut" "$shortcut_file"
        fi
        if [[ -f "$shortcut_file" ]]; then
            open "$shortcut_file"
            sleep 2
            shortcuts run "scut-test" 2>&1 || true
        fi
    fi

    rm -rf "$tmp_dir"
    echo ""
    echo "Cleanup complete."
}

# @cmd Export installed shortcut as readable plist
# @arg name! Shortcut name
# @flag --json Output as JSON instead of plist
dump() {
    _require_shortcuts_db
    local name="${argc_name}"

    local tmp_plist
    tmp_plist=$(mktemp /tmp/scut-dump-XXXXXX.plist)

    _sdb "SELECT writefile('$tmp_plist', ZDATA)
          FROM ZSHORTCUTACTIONS
          WHERE ZSHORTCUT = (
              SELECT Z_PK FROM ZSHORTCUT WHERE ZNAME = '$(_sq "$name")'
          );" > /dev/null

    if [[ ! -s "$tmp_plist" ]]; then
        rm -f "$tmp_plist"
        # Try case-insensitive match
        _sdb "SELECT writefile('$tmp_plist', ZDATA)
              FROM ZSHORTCUTACTIONS
              WHERE ZSHORTCUT = (
                  SELECT Z_PK FROM ZSHORTCUT WHERE ZNAME LIKE '$(_sq "$name")' LIMIT 1
              );" > /dev/null
    fi

    if [[ ! -s "$tmp_plist" ]]; then
        rm -f "$tmp_plist"
        echo "Shortcut '$name' not found. Available shortcuts:"
        _sdb "SELECT ZNAME FROM ZSHORTCUT
              WHERE ZTOMBSTONED = 0 OR ZTOMBSTONED IS NULL
              ORDER BY ZNAME;" | while read -r n; do
            echo "  $n"
        done
        exit 1
    fi

    if [[ "${argc_json:-}" == "1" ]]; then
        plutil -convert json -o - "$tmp_plist" 2>/dev/null || \
            plutil -p "$tmp_plist"
    else
        plutil -p "$tmp_plist"
    fi

    rm -f "$tmp_plist"
}

# @cmd Import a .shortcut file (opens Shortcuts.app import dialog)
# @arg file! Path to .shortcut file
import() {
    local file="${argc_file}"
    [[ -f "$file" ]] || _die "File not found: $file"
    echo "Opening Shortcuts import dialog..."
    open "$file"
}

# ─── Phase 4: Reference ──────────────────────────────────────────────

# @cmd Generate full markdown action reference document
# @arg file Output file path (default: stdout)
doc() {
    _require_db

    local output="${argc_file:-/dev/stdout}"

    {
        echo "# Available Shortcuts Actions"
        echo ""
        echo "Generated: $(date)"
        echo ""

        local total apple thirdparty
        total=$(_sql "SELECT COUNT(*) FROM Tools;")
        apple=$(_sql "SELECT COUNT(*) FROM Tools WHERE id LIKE 'com.apple.%';")
        thirdparty=$(_sql "SELECT COUNT(*) FROM Tools
                           WHERE id NOT LIKE 'com.apple.%' AND id NOT LIKE 'is.workflow.%';")

        echo "| Category | Count |"
        echo "|----------|-------|"
        echo "| Total actions | $total |"
        echo "| Apple actions | $apple |"
        echo "| Third-party actions | $thirdparty |"
        echo ""

        echo "## Third-Party Actions by App"
        echo ""

        local current_app=""
        while IFS='|' read -r action_id name app_name; do
            local bundle_id
            bundle_id=$(_bundle_from_id "$action_id")
            if [[ "$bundle_id" != "$current_app" ]]; then
                current_app="$bundle_id"
                echo ""
                echo "### $app_name ($bundle_id)"
                echo ""
                echo "| Action | Identifier |"
                echo "|--------|------------|"
            fi
            local action_short="${action_id##*.}"
            echo "| ${name:-$action_short} | \`$action_id\` |"
        done < <(_sql "
            SELECT t.id, COALESCE(tl.name, ''), COALESCE(cml.name, cm.id)
            FROM Tools t
            JOIN ContainerMetadata cm ON t.sourceContainerId = cm.rowId
            LEFT JOIN ContainerMetadataLocalizations cml ON cm.rowId = cml.containerId AND cml.locale = 'en'
            LEFT JOIN ToolLocalizations tl ON t.rowId = tl.toolId AND tl.locale = 'en' AND tl.localizationUsage = 'display'
            WHERE t.id NOT LIKE 'com.apple.%' AND t.id NOT LIKE 'is.workflow.%'
            ORDER BY cm.id, t.id;
        ")

        echo ""
        echo "---"
        echo ""
        echo "*Generated by \`scut doc\`. Use \`scut params <action>\` for parameter details.*"
    } > "$output"

    if [[ "$output" != "/dev/stdout" ]]; then
        echo "Generated: $output"
    fi
}

# @cmd Show Shortcuts development community resources and references
community() {
    cat << 'COMMUNITY'
Shortcuts Development Community & Resources
============================================

GitHub Repos (source code is the real docs):
  sebj/iOS-Shortcuts-Reference     Plist format, action IDs, parameter types
  joshfarrant/shortcuts-js          JS lib for programmatic shortcut generation
  electrikmilk/cherri               Cherri compiler source
  Shortcuts File Format wiki        Plist ↔ JSON tooling

People:
  Matthew Cassinelli                Former Apple Shortcuts team member
    matthewcassinelli.com           Deepest public knowledge of action internals
  Federico Viticci (MacStories)     Most thorough published Shortcuts writing
  Rosemary Orchard                  Automators podcast host, Shortcuts internals expert
    rosemaryorchard.com             Active on Mastodon/Twitter — very responsive to questions
  Alex Hay (1990–2023)              Toolbox Pro creator, extension app pioneer
    MacStories memorial article     Community context and key people overview
  snailedit.dev                     Team continuing Alex Hay's work (FocusCuts, etc.)

Communities:
  r/shortcuts                       Search: "plist", "rawAction", "WFWorkflowAction"
  talk.automators.fm                Rosemary + David Sparks — best for deep technical Q&A
  RoutineHub Discord                Shortcut devs hang out here
  toolboxpro.app                    Toolbox Pro support and extension app community

Apple Developer Docs (App Intents framework):
  App Intents documentation         Official framework reference
  "Creating Your First App Intent"  Step-by-step tutorial
  WWDC25 "Explore New Advances"     Latest App Intents session
  Apple Developer Forums            Search: "App Intents", "file handling"

Identifier Format Conventions:
  Apple built-in:    is.workflow.actions.{name}
  Third-party:       {bundleId}.{IntentName}Intent
  Apple system:      com.apple.{framework}.{IntentName}
COMMUNITY
}

# ─── Phase 5: Library Management ─────────────────────────────────────
# Hybrid backend: AppleScript for folder/create ops, SQLite for everything else.

# @cmd Manage installed shortcuts: list, delete, rename, organize, inspect
# @meta default-subcommand list
manage() { :; }

# @cmd List installed shortcuts
# @option -f --folder-name Filter by folder name, or "none" for unfoldered
# @flag --folders List folders instead of shortcuts
# @flag --ids Show workflow IDs
# @flag --json Machine-readable JSON output
manage::list() {
    _require_shortcuts_db

    if [[ "${argc_folders:-}" == "1" ]]; then
        if [[ "${argc_json:-}" == "1" ]]; then
            _require_jq
            local json="[]"
            while IFS= read -r fname; do
                [[ -z "$fname" ]] && continue
                local count
                count=$(shortcuts list --folder-name "$fname" 2>/dev/null | wc -l | tr -d ' ')
                json=$(echo "$json" | jq --arg name "$fname" --arg count "$count" \
                    '. + [{name: $name, shortcut_count: ($count|tonumber)}]')
            done < <(shortcuts list --folders 2>/dev/null)
            echo "$json" | jq .
        else
            echo "Folders:"
            local has_folders=0
            while IFS= read -r fname; do
                [[ -z "$fname" ]] && continue
                has_folders=1
                local count
                count=$(shortcuts list --folder-name "$fname" 2>/dev/null | wc -l | tr -d ' ')
                printf "  %-30s %s shortcuts\n" "$fname" "$count"
            done < <(shortcuts list --folders 2>/dev/null)
            if [[ $has_folders -eq 0 ]]; then
                echo "  (no folders)"
            fi
        fi
        return
    fi

    local cmd="shortcuts list"
    if [[ -n "${argc_folder_name:-}" ]]; then
        cmd+=" --folder-name '${argc_folder_name}'"
    fi
    if [[ "${argc_ids:-}" == "1" ]]; then
        cmd+=" --show-identifiers"
    fi

    if [[ "${argc_json:-}" == "1" ]]; then
        _require_jq
        local json="[]"
        while IFS= read -r sname; do
            [[ -z "$sname" ]] && continue
            local row
            row=$(_sdb "SELECT Z_PK, ZACTIONCOUNT, ZPHRASE,
                        datetime(ZCREATIONDATE + 978307200, 'unixepoch'),
                        datetime(ZMODIFICATIONDATE + 978307200, 'unixepoch'),
                        ZWORKFLOWID
                 FROM ZSHORTCUT
                 WHERE ZNAME = '$(_sq "$sname")'
                   AND (ZTOMBSTONED = 0 OR ZTOMBSTONED IS NULL)
                 LIMIT 1;")
            local pk actions phrase created modified wfid
            IFS='|' read -r pk actions phrase created modified wfid <<< "$row"
            json=$(echo "$json" | jq \
                --arg name "$sname" \
                --arg pk "${pk:-}" \
                --arg actions "${actions:-0}" \
                --arg phrase "${phrase:-}" \
                --arg created "${created:-}" \
                --arg modified "${modified:-}" \
                --arg wfid "${wfid:-}" \
                '. + [{name: $name, pk: ($pk|tonumber? // null), action_count: ($actions|tonumber? // 0),
                        siri_phrase: (if $phrase == "" then null else $phrase end),
                        created: $created, modified: $modified, workflow_id: $wfid}]')
        done < <(eval "$cmd" 2>/dev/null)
        echo "$json" | jq .
    else
        eval "$cmd" 2>/dev/null
    fi
}

# @cmd Delete a shortcut (tombstone in database)
# @arg name! Shortcut name (exact match)
# @flag --force Skip confirmation
manage::delete() {
    _require_shortcuts_db
    local name="${argc_name}"

    local pk
    pk=$(_sdb "SELECT Z_PK FROM ZSHORTCUT
               WHERE ZNAME = '$(_sq "$name")'
                 AND (ZTOMBSTONED = 0 OR ZTOMBSTONED IS NULL)
               LIMIT 1;")
    if [[ -z "$pk" ]]; then
        _die "Shortcut '$name' not found"
    fi

    if [[ "${argc_force:-}" != "1" ]]; then
        printf "Delete shortcut '%s'? [y/N] " "$name"
        read -r confirm
        [[ "$confirm" =~ ^[Yy] ]] || { echo "Cancelled."; return; }
    fi

    _sdb "UPDATE ZSHORTCUT SET ZTOMBSTONED = 1 WHERE Z_PK = $pk;"
    echo "Deleted '$name'"
}

# @cmd Batch delete shortcuts matching a pattern
# @arg pattern! Glob pattern (SQL LIKE: % for wildcard)
# @flag --force Skip confirmation
# @flag --dry-run Show what would be deleted without deleting
manage::delete-matching() {
    _require_shortcuts_db
    local pattern="${argc_pattern}"

    local matches
    matches=$(_sdb "SELECT ZNAME FROM ZSHORTCUT
                    WHERE ZNAME LIKE '$(_sq "$pattern")'
                      AND (ZTOMBSTONED = 0 OR ZTOMBSTONED IS NULL)
                    ORDER BY ZNAME;")

    if [[ -z "$matches" ]]; then
        echo "No shortcuts matching '$pattern'"
        return
    fi

    local count
    count=$(echo "$matches" | wc -l | tr -d ' ')

    echo "Matching shortcuts ($count):"
    while IFS= read -r m; do
        echo "  $m"
    done <<< "$matches"

    if [[ "${argc_dry_run:-}" == "1" ]]; then
        echo "(dry run — nothing deleted)"
        return
    fi

    if [[ "${argc_force:-}" != "1" ]]; then
        printf "Delete all %s shortcuts? [y/N] " "$count"
        read -r confirm
        [[ "$confirm" =~ ^[Yy] ]] || { echo "Cancelled."; return; }
    fi

    _sdb "UPDATE ZSHORTCUT SET ZTOMBSTONED = 1
          WHERE ZNAME LIKE '$(_sq "$pattern")'
            AND (ZTOMBSTONED = 0 OR ZTOMBSTONED IS NULL);"
    echo "Deleted $count shortcuts"
}

# @cmd Rename a shortcut
# @arg name! Current shortcut name
# @arg new_name! New name
manage::rename() {
    _require_shortcuts_db
    local name="${argc_name}"
    local new_name="${argc_new_name}"

    local pk
    pk=$(_sdb "SELECT Z_PK FROM ZSHORTCUT
               WHERE ZNAME = '$(_sq "$name")'
                 AND (ZTOMBSTONED = 0 OR ZTOMBSTONED IS NULL)
               LIMIT 1;")
    if [[ -z "$pk" ]]; then
        _die "Shortcut '$name' not found"
    fi

    _sdb "UPDATE ZSHORTCUT SET ZNAME = '$(_sq "$new_name")' WHERE Z_PK = $pk;"
    echo "Renamed '$name' → '$new_name'"
}

# @cmd Change a shortcut's icon color and/or glyph
# @arg name! Shortcut name
# @option --color Icon background color (red, orange, yellow, green, blue, purple, pink, gray, or integer)
# @option --glyph Glyph number (SF Symbol code point as integer)
manage::icon() {
    _require_shortcuts_db
    local name="${argc_name}"

    local icon_pk
    icon_pk=$(_sdb "SELECT si.Z_PK FROM ZSHORTCUTICON si
                    JOIN ZSHORTCUT s ON s.ZICON = si.Z_PK
                    WHERE s.ZNAME = '$(_sq "$name")'
                      AND (s.ZTOMBSTONED = 0 OR s.ZTOMBSTONED IS NULL)
                    LIMIT 1;")
    if [[ -z "$icon_pk" ]]; then
        _die "Shortcut '$name' not found or has no icon"
    fi

    if [[ -n "${argc_color:-}" ]]; then
        local color_val
        case "${argc_color}" in
            red)     color_val=4294901760 ;;
            orange)  color_val=4294944000 ;;
            yellow)  color_val=4294957056 ;;
            green)   color_val=4283215696 ;;
            blue)    color_val=4282601983 ;;
            purple)  color_val=2846468607 ;;
            pink)    color_val=4293591295 ;;
            gray)    color_val=2240066815 ;;
            *)       color_val="${argc_color}" ;;
        esac
        _sdb "UPDATE ZSHORTCUTICON SET ZBACKGROUNDCOLORVALUE = $color_val WHERE Z_PK = $icon_pk;"
        echo "Set color of '$name' to ${argc_color}"
    fi

    if [[ -n "${argc_glyph:-}" ]]; then
        _sdb "UPDATE ZSHORTCUTICON SET ZGLYPHNUMBER = ${argc_glyph} WHERE Z_PK = $icon_pk;"
        echo "Set glyph of '$name' to ${argc_glyph}"
    fi

    if [[ -z "${argc_color:-}" && -z "${argc_glyph:-}" ]]; then
        # Show current icon info
        local color glyph
        IFS='|' read -r color glyph < <(_sdb "SELECT ZBACKGROUNDCOLORVALUE, ZGLYPHNUMBER FROM ZSHORTCUTICON WHERE Z_PK = $icon_pk;")
        echo "Icon for '$name': color=$color glyph=$glyph"
    fi
}

# @cmd Set or clear Siri phrase for a shortcut
# @arg name! Shortcut name
# @arg phrase Siri phrase (omit to clear)
manage::phrase() {
    _require_shortcuts_db
    local name="${argc_name}"
    local phrase="${argc_phrase:-}"

    local pk
    pk=$(_sdb "SELECT Z_PK FROM ZSHORTCUT
               WHERE ZNAME = '$(_sq "$name")'
                 AND (ZTOMBSTONED = 0 OR ZTOMBSTONED IS NULL)
               LIMIT 1;")
    if [[ -z "$pk" ]]; then
        _die "Shortcut '$name' not found"
    fi

    if [[ -z "$phrase" ]]; then
        _sdb "UPDATE ZSHORTCUT SET ZPHRASE = NULL WHERE Z_PK = $pk;"
        echo "Cleared Siri phrase for '$name'"
    else
        _sdb "UPDATE ZSHORTCUT SET ZPHRASE = '$(_sq "$phrase")' WHERE Z_PK = $pk;"
        echo "Set Siri phrase for '$name' to '$phrase'"
    fi
}

# @cmd Move a shortcut into a folder (via AppleScript)
# @arg name! Shortcut name
# @arg folder! Target folder name
manage::move() {
    local name="${argc_name}"
    local folder="${argc_folder}"
    osascript -e "tell application \"Shortcuts Events\" to move shortcut \"$name\" to folder \"$folder\"" 2>&1 \
        || _die "Failed to move '$name' to folder '$folder'"
    echo "Moved '$name' → folder '$folder'"
}

# @cmd Create an empty shortcut (via AppleScript)
# @arg name! Shortcut name
manage::create() {
    osascript -e "tell application \"Shortcuts Events\" to make new shortcut with properties {name:\"${argc_name}\"}" 2>&1 \
        || _die "Failed to create shortcut '${argc_name}'"
    echo "Created empty shortcut '${argc_name}'"
}

# @cmd Inject actions into a shortcut from a plist file
# @arg name! Shortcut name
# @arg plist! Path to XML or binary plist with action array
manage::inject() {
    _require_shortcuts_db
    local name="${argc_name}"
    local plist="${argc_plist}"

    [[ -f "$plist" ]] || _die "File not found: $plist"

    local pk
    pk=$(_sdb "SELECT Z_PK FROM ZSHORTCUT
               WHERE ZNAME = '$(_sq "$name")'
                 AND (ZTOMBSTONED = 0 OR ZTOMBSTONED IS NULL)
               LIMIT 1;")
    if [[ -z "$pk" ]]; then
        _die "Shortcut '$name' not found"
    fi

    local tmp_bplist
    tmp_bplist=$(mktemp /tmp/scut-inject-XXXX.bplist)

    # Convert to binary plist if needed
    if file "$plist" | grep -q "XML"; then
        plutil -convert binary1 -o "$tmp_bplist" "$plist" || _die "Failed to convert plist"
    elif file "$plist" | grep -q "binary"; then
        cp "$plist" "$tmp_bplist"
    else
        # Try converting anyway
        plutil -convert binary1 -o "$tmp_bplist" "$plist" || _die "Not a valid plist: $plist"
    fi

    local hex
    hex=$(xxd -p "$tmp_bplist" | tr -d '\n')
    _sdb "UPDATE ZSHORTCUTACTIONS SET ZDATA = x'$hex' WHERE ZSHORTCUT = $pk;"
    rm -f "$tmp_bplist"

    echo "Injected actions into '$name'"
}

# @cmd Show run history for shortcuts
# @option --limit <int> Max results (default: 20)
# @flag --json Machine-readable JSON output
manage::history() {
    _require_shortcuts_db
    local limit="${argc_limit:-20}"

    if [[ "${argc_json:-}" == "1" ]]; then
        _require_jq
        local json="[]"
        while IFS='|' read -r sname runs last_run; do
            json=$(echo "$json" | jq \
                --arg name "$sname" \
                --arg runs "$runs" \
                --arg last "$last_run" \
                '. + [{name: $name, run_count: ($runs|tonumber), last_run: $last}]')
        done < <(_sdb "
            SELECT s.ZNAME, COUNT(re.Z_PK) as runs,
                   datetime(MAX(re.ZDATE) + 978307200, 'unixepoch') as last_run
            FROM ZSHORTCUTRUNEVENT re
            JOIN ZSHORTCUT s ON re.ZSHORTCUT = s.Z_PK
            GROUP BY s.ZNAME
            ORDER BY runs DESC
            LIMIT $limit;
        ")
        echo "$json" | jq .
    else
        echo "Run history (top $limit):"
        echo ""
        printf "  %-35s %6s  %s\n" "Shortcut" "Runs" "Last Run"
        printf "  %-35s %6s  %s\n" "─────────────────────────────────" "─────" "───────────────────"
        while IFS='|' read -r sname runs last_run; do
            printf "  %-35s %6s  %s\n" "$sname" "$runs" "$last_run"
        done < <(_sdb "
            SELECT s.ZNAME, COUNT(re.Z_PK) as runs,
                   datetime(MAX(re.ZDATE) + 978307200, 'unixepoch') as last_run
            FROM ZSHORTCUTRUNEVENT re
            JOIN ZSHORTCUT s ON re.ZSHORTCUT = s.Z_PK
            GROUP BY s.ZNAME
            ORDER BY runs DESC
            LIMIT $limit;
        ")
    fi
}

# @cmd Manage folders
manage::folder() { :; }

# @cmd Create a new folder (via AppleScript)
# @arg name! Folder name
manage::folder::create() {
    osascript -e "tell application \"Shortcuts Events\" to make new folder with properties {name:\"${argc_name}\"}" 2>&1 \
        || _die "Failed to create folder '${argc_name}'"
    echo "Created folder '${argc_name}'"
}

# @cmd Delete a folder (via AppleScript)
# @arg name! Folder name
# @flag --force Skip confirmation
manage::folder::delete() {
    local name="${argc_name}"

    if [[ "${argc_force:-}" != "1" ]]; then
        local count
        count=$(shortcuts list --folder-name "$name" 2>/dev/null | wc -l | tr -d ' ')
        if [[ "$count" -gt 0 ]]; then
            printf "Folder '%s' contains %s shortcuts. Delete anyway? [y/N] " "$name" "$count"
            read -r confirm
            [[ "$confirm" =~ ^[Yy] ]] || { echo "Cancelled."; return; }
        fi
    fi

    osascript -e "tell application \"Shortcuts Events\" to delete folder \"$name\"" 2>&1 \
        || _die "Failed to delete folder '$name'"
    echo "Deleted folder '$name'"
}

# @cmd List folders
# @flag --json Machine-readable JSON output
manage::folder::list() {
    # Route to manage list --folders; re-export json flag
    local argc_folders=1
    manage::list
}

# @cmd Purge tombstoned shortcuts and orphaned icon rows
manage::cleanup() {
    _require_shortcuts_db

    local tombstoned
    tombstoned=$(_sdb "SELECT COUNT(*) FROM ZSHORTCUT WHERE ZTOMBSTONED = 1;")

    if [[ "$tombstoned" -eq 0 ]]; then
        echo "Nothing to clean up."
        return
    fi

    echo "Tombstoned shortcuts: $tombstoned"

    # Show what will be purged
    while IFS= read -r sname; do
        echo "  - $sname"
    done < <(_sdb "SELECT ZNAME FROM ZSHORTCUT WHERE ZTOMBSTONED = 1 ORDER BY ZNAME;")

    printf "Permanently purge these from the database? [y/N] "
    read -r confirm
    [[ "$confirm" =~ ^[Yy] ]] || { echo "Cancelled."; return; }

    # Delete orphaned icons, actions, then the shortcuts
    _sdb "DELETE FROM ZSHORTCUTICON WHERE Z_PK IN (
              SELECT ZICON FROM ZSHORTCUT WHERE ZTOMBSTONED = 1);"
    _sdb "DELETE FROM ZSHORTCUTACTIONS WHERE ZSHORTCUT IN (
              SELECT Z_PK FROM ZSHORTCUT WHERE ZTOMBSTONED = 1);"
    _sdb "DELETE FROM ZSHORTCUTRUNEVENT WHERE ZSHORTCUT IN (
              SELECT Z_PK FROM ZSHORTCUT WHERE ZTOMBSTONED = 1);"
    _sdb "DELETE FROM ZSHORTCUT WHERE ZTOMBSTONED = 1;"

    echo "Purged $tombstoned shortcuts and associated data"
}

# ─── Dispatcher ──────────────────────────────────────────────────────
eval "$(argc --argc-eval "$0" "$@")"
